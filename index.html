<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #1D5D9B;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #1D5D9B;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #75C2F6;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p><p>The first number is one number greater than the fourth number.<br />
The second number is the root of the first number.<br />
The third number is two times the first number.<br />
The sum of four numbers is 20.<br />
Find the 4-digit code to unlock your extra gift.</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Show Me" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e953cbea766e1813c2c075a07cedae21af5a20a08fa145d3b45e76f9b4383d7cb772392695599d630ef0e0f01058ebc5d2d9adc71460a93db4bb6ab2fc77005c69523de1b235aec151e396ae0d93bbf002e255e784c8c28de0beaea5975e9b03618cf6e29d1ca6332e6ab4cb31076644538083c238198a3d3384cd2ffb40e84e8d30960e474dd1fe67a7fcecc3f0afe9c9bf80d5cc3553c708c4dfb7163c13149934adef34e4f78e7b8b1ff225af2414c2fb93012216fe47067fa92849abbaeb5db20f5dbaa2c5fe2f497041b0ebb3d28643494e22f8bd8842fcc070ced5b843d98871479b2f5b4d13243050a9eeae773a1ba344e38e9e097bb7a7bd9978e38aaacc1469ca9862346e6ef1267b338fca627acd2187f27ecbf202ee1b6c32ebe6633498b3d219dd0e9f4fe379285bfc5926c854168aa25ef4fe865c98a0eaa562dbb7e0a4f9015b5077205383afdf258017b87fba8519a20e0d82b9f574a219716531bab40b594a7204d3a53d5e2331ca88a9c56ae3e7dc816df29e0a1edc11bf7954b6b93c2eef68592b0ba51ccd55be71e35438a2901b1521fc5ae2851ee13d72a61830bcc748b3aa7040ade93e3a411a9e13f11e0ce483c03fa14037afaad6d5f490e13a120ed2871d59f4a2803b62fa5fd0d5edaba00b73a89fad6c601fe045f121b9623201f4402654733deafe6532f5fad2162c8e5454baa20279ca46d1d4702ca36278c7676cffbd399196bc25563697854708509a9558e7c453455dc44d531964b8f999d874a26852dffe80aa244039faf925dfea1454fb38a6ab9de28c03abddd33c33f8bffb1edc1a5092ff26db5dc88a50f78cdfc5fe7422a9d6899811248f180a9a6e50b4fcfcb133a46b72398bf207d277b2a906aca8d740d2ea6d521790731e110091e5b372226270efb810c582150568b572c07d20be3158bff348e056e102144cf762e53fb99ee40dc8ba38251e30888495539448831624e515af8da2ce7bb7404404b2825b7475f3de2d4090b518945f2dc84c65c6783b686f957793562628252b39c7c625765642cf3ff1b31994195e938ab3c1aad0e19965bba2c20ec5e14b6b9d766cb2829368f9ab7ebb4f1080d837dc1445d966b48afa7b356ff4ad90534021b7ce0cbf71bb9276b4859c41b11b354a77def91a036534b1521fef19f9a2aab59240485db75d8709d536245cca907af4db8e8cd181eb378901f4e6977b9476e7fab820df8d5b95ae900570df62c4340ee7dc1be2362cb3c911850468ae9ec5fd2401032d8d393df9a6a7fd0b20cdf9852a215efe428fa96a8f628e20eaa86af072dded99d32850ce24a50390a2dc722132f75549141f482c588b87895259a12b1b7125d11c75712786ab9b41ea64ace3a55142d18f3ded7ac8223d5c4fc4b4b75e4ba4ae45462355ff0d4b24e167a238cbe3dd3fe277db38eeeb2dd0e0073f84ece9de149af16b3435c25406f21fba3fb0df1c1a1f4f286cd81d87c591ada67ba3f7a80b520278fbc82a84985a93c0fe062853de93adbe705b9f23ac681daad415b31168e55c071bc92fc6749ea678ca3336293d62990c599bcde5175c40b959c5799d3e3c597be20d52eba8ec7a629653ab418c5dd3128bf6f6433421084a772195f81d2326095dda72341b0ef8a9ccd50fcae7bd7e18698f61b29b7cdab62facff748e94733148bf21aceb85e0b48c865beb90b8c1677330799ae8e7caeb3f888fd99853bb5497a2462698927962ac584408b4d3d14ae8c1f98679d858f1d53b9ec54bff7a391c4534a197a66797579e39ff0e481298737205b284dad5a96c7a75328217e0fa0751657b84469a1587ac6169ff8801f6b0a4782d951cd2926de89c675f7a5d5e9621a9abd0d0cb80a2a3d45f8cdc44b73f50447f807b36744c933db0b682a377879123490fae580d13d10d3710d74f086a023aa45ca04b7f65a99584fb0a653b4d88a38437363fe20f86277f641ba692c3b2384d59942ece83208da23d77acc2f96c1aebfee8fa2b1a3c95b8b3f9240226f2e15bbdb08c7d5c51ac30b568fff49a9bb56e1eceed0f51ef482fd79b168c300a20bed17f9a74c16232d7b2e9526eb12674de8878b93c4ee8390be1f27a9b84926466e80327afac0568f1ca5a56914208f0b3af3a2d89b5a4583373859939e1b8f65070c0c4818a25c313e1f7d4a78d4ccf237485c30dc9cd8bc3aa7d2ca7298e2b1c95b382d12861d723473d56aa9990b9d9967f227b1e290b3bb7e0af9578d979289cdb210f4251602df8f1a0f0debc661c8e684ebc83186a9a2eb801bc55b33328bc27828074a27941c165a599c85d1d59cfae44a424d4bd27c6a0231bb517f949fcc9b34d9044271a7abd0c4a28b617fd24914194b064f7653fc6659e0609f35ac41ad1f5bd499835ee0d1d6435d2ff11a9dec1d573995f28b1248b245bce453f524b1d377ea9104ddbca9a5a87c01a1a9890eebef2c4a5e3dfa15114f99446c4be71f7471c103b2d6c40c3d62e5d00beae1648657f418c451bfa3a2c0cfe5224dda1716f274b33fad116ea73750f4017923286bb748197106ed76314cc015143d6fbe4cd285f75716194ef385e1c923bd09c375131bb3a73b2f50387d4460c055eb8575074bfda0d2597dc51fa7c9117f1a4c7515888f52b1c72bbb5bc0b8060eb19c882b987b5a5af32f8692dc8efb77f7e043f3b9faf882e18aa4b461d32223ca5653018ae95c8c410ad9740b76f88daa1e4406a9aab38715c3c640551987e6a453ab866c00c48f705e26fc9150412e81593d38e7f3cdfd45d2d647f2ffe375f411c2d8a479196cbae432b588a12de430ef8cdf4799c2271940afd5b6771d18938d43d56298ae8bceacefb4dd8a1fd1ec025644acc277eba3967b00651c9dd344728f16354556a001fee4b95b45f8475d52926d4cd2abbe7b6d76871f70673a1519062fdbb5f675126f34aa82c41126dacd58a7434822dea9d53d688b71552ed2b12ee8edd27b93b6b22d445466b6a2e5da3d59a136a93518a02d36fa0949e98abd2fe938c6c6800558ea7c5b095c5523d799e21b7ce06ff8e42226899f4ff3e2ceac28a4dff13859662355c1eed69cb6b56f0c230a8130ec7364cd350690c9bfa0e813568ae776ed63e116f87a32401583f375fe6f01448defe32a0ea2a2f09714fa0761f5707ab0042126d42c58a5c497e35eea863a5d493154748a6419d47c57cf357fdf46a8e4cebc6ac1ddfe7c2e6d35ed8e15718c94c049fd2ff9f0f5a87d26b0e6c574463921cf23bffd6528cb91c2dd578cbcce40899b279914b07bd4005739e074176596e08b6f06c016d2fd7e7483337567b811aa6bfe0ad85e25113b3ed28c66c61b4d1b2e43c27292c14ca831b80109436989c2e9cd59767dee4849c67844efe9e954263405a53f124cf2004369f87845d93adbf9e7651c9e15d7c7f5b700863a8df7a526b8cd134daf57330ae451c0949e36f27e3560de438d8596909153e24d2b83ac41e5e9220b32d943691570fb0769fad4e7b0a87d8edf895bd6e0972a87fec67a84561a07ded624ab79c73313741ed462628ebea339d73441804c3f013870a68cf5c7cb267329534e949260ec1b6b23148b42adee24abd3caa2415b728e73d06a527290c62bdb03b919ac493416dce986da6565d7b95982442dfa1f45785da0c0caccd58fc6dbd13ee05f8e91601bcf4457dcd13dd85ea2eebdb4b215ee6b624fc2000b22c8b046de0f9f797319d9536a6096b064198110b6f9128ab740d80955714e5b80d102137a9eb633c2464aa46ffa75f86acb7d378dc7c2560b49cf5bc37d002377ae4a9537e37bc9d77c04d2d5d05d4c55a105ed191818842b6b74483b0cc6780f7b7cd40308d75114890072035dc9f5d85cec6c4be1ea5fcebceec341ff794cdf537e5515dc4d3b25d2f79906d39f9f95f6b47fed9e0270cf374e01342279fb49aa954ad06276ad23b774959bdb33093c3d2f7eca20a4a5778414b58a908bf9bd208baa5df0a71f58289af18ec612c022eef5cc8ebce5a328938ea3e2b62fccfdb0b194ded24ed33bd0b7253d646d7c63021fed52fd2551d6decc6e868acc702d2f33e5e7af8c33ae5c6a4f289b10bcfd194899a511be10c893fdb327bdd7daaf7299de7bc529ef489489eeeb1743f6c727445f840e1e0871909a42b58a182bcbfe6a38a451283ab9376ccc545d216fb6a26aa8431e662690f1e98d9fc8fa0ea551939c765b466dc932c53735a06d65dbc522c4cf22822622a1794e26af3495509325f6b8a3add2fdb22bb1007fce6606f4bf5520b6ce4d72579ffc14eac53db209221de2639dcecaa63385e4ecddb937e245ed59403a2095cd87737c8c1726affd829c8a4532b9077469159a0691424876163d080e108721694b25154e00570623ef2aeef785df23fdad3983dbe6fb81f063dfe5988f83f833ad619b2bbde73986b9eb0958811cf16488281a9ee65aad6d56d90955d2840d04ea21e786903c732bc09ef0b0de2bf3f2fe0e08bc8daebe47c3e38f5e934798fb51423c91176788545f0ea701352bc2c27b6e52cf8841692ab9d63800a4ec232b3c508657913e6e3b29e8f95f58d0bfd3b3f1e834427fba2334b2cd14739d895e06c1286573e3da7c2cdb50f6f90bc250810ee08c019999d576339478a48d9ccb147ede2e6e1983fa1fd59f39d6c6acb562c5c17686c8c873021dd4b3d7edacb5df8c5c71d025385f38aabd606f8e450e5899b58282aba8a7386e66f850bf3872af51e18c4b430a4f4e3aced32f9c5aaba0bbc74d25433f24f17e6635b0b261278e12d630a5bf745ab5af55d0c534abc00273ab1d841f9b887a8ffc4d4771c359b62820faa29bcd8f4e3248de9d179a0438ff749b23e90ecfe7b3521d93aa6d6ea82be759fa959be9d8e96b9593531504ce4ac40db665c4e345b47b7eeb8e75c3d29bf54ac0a94c33404eb52403eee41e8f445a18d2c76443e9d9d92395d857e848f55dfe323851ae9e54bd0d4b7e756a46419ea9cd62e1150bbde5119f61571540730bdc1be8fb12e463fd11d1490fdf7647cda7c726a739ab2ba665ec034bd8e6ef171d0b17a7fbdb4e5f820e50a2b01d2285fe01e31a70d27a90fa57a4374f4c8cad6573835e39f1901d514ebcce75b11c3db5651450a114dbc78ce9072037a0b99c91b83a1e65628efffa391fc05754c7dc1e17fd8643880bb14cc30c72b13383fa7f9d6e42e1d8a1c61c84cba8aba9157f2a965918081e1ad24fbb3714d85e99ee87b1f8b0eec2aaadcffa3b7cc844fa2186841f2f751f4b088c70c0c66638489a70cc96c33b3b07e638a77ae49f806ac49f7d0ec282f1771ae6ef0145c005afdc20adb49f5034cd303459d3b7b0f96546cfd7cedf50f4dc1bae64ac663fd8ff70cc5d62c89e33243bdb28d40934e469b99d64ccea10358866b09e937cc2cc0a84a25d38dba9e769b5a3729644ffab4567a7187238ddf41b09516c221dbb3914585ae0f56b98fa97aade2159bf5d831c1ecbafb26217967d70fca539597178cceb8aed47db50fc693b627b1f91e5d9316751e52c3e574367a6497527d3810924de711b0536e4780cb772346077558b2ef6101a059d12581c2cca45dd6e9841781e9eb5b2bb6762f0edf5036884f9a6b0e36c66c69a3d389c59fe09d669be4bd80ccd3d19b2884f81133bae7f31f10e2b1a7e4bc59d366cfc3f2dc853d6b2e9ae244a3192de0c0006f390b16eec2fd130502778f32ae7507d597a6452ca07506a29abc44f0db2c4aeffeeba123c60415201c33e9f43f9a59a78353bd05ba71e9d02933eb59e5edaf05a04a30ada5896d8abf052914b39c4efd11cd82e109af96b344a55730070b1726cfa9746eb5b19b98bc1f5823805582a3b44f58135dcfee742cf77784d30de4d581876d7663ab3cdca67d0d0d4b52bd70c390a74b2e7c95d7a25d9f2d26c55c6477da675a4708a530558f455bf90a854bea03210ec382bd7b25a97e80117642f88b413a36af36340aa6a0c33ce65e5aba78a2add5f3bf567b4f7faecdc1c3f25ddb7cc597394af68c30d1cbeb12d525976057966cb829ba68cb9c9ac47425837ad9cb52cb31084051399f040f25380be73c33415663db47aaccc79273bcff781a68e325ed8ffaad6803b2b17ddd8740f602226e3feade37c04cca69b74b4dc588bdb4db096230e359d0a7ccef495cbe0a867064ad79afc7d38305c295ed9f43ec654ec9c4cfe0251597d87508a99d9ef23afc11bdd4710f84a082d3dbae57b6ddc237d3d26eda61e7b8328a9889b7a305cff272e7612ed6590c8914475ca94fb9ef070f799e16e91625cd598abde49b576e4949a6c27694a1e59da1858e0db0e6b6a4e7fa0cf5f0e0300e02f57a39317cb9b4d25b3061302e3221c9e7cf16c33a6cae77552b5e7d49965e0d498293922234fa887750f837c7f35e5d78d1426e16ba153bd867d61a6b99a418b3a18d68b8d69bda016a30dc11aa888bee6f25dadc16e1d99746b31d4de4d2ac5548418b4be89450e805f9953ca8cb4eae9cf54c4e9a66f5130b8174ce3d695757d9326791859e766393233fcf7f2ec0c3d10f577753e1ff9910b2ec525a25fb4cfe1c1119f8e5e73b787a35f245829bdad1ee0327a7d650d97c36b7e49b12f05ee5ff8326b10812ac67c0179cc3b00985e88cf0cca1f9307d703ca55eecb9d5345c8a0de416fc456d10ca53ab1cad4876eaada2b641b3db94188f41b4aa476dd798b52c030f9f15f6cde32776687023c162d6d1cb3d7986015af07938e2b5177b045bc64436587ea4456b12f61cc6b5959df3d08885853a2e3813cdb130e1c3b1d44d47126698b08e64b7b5c24ee8e3fc32ac82e7735c3f1e93b24253dd9024d6d038eb9ce352f4841b11bbdc643e8cbfe793d885cf375a56fb6f8a95d5cbb067d6d1241512082fb0beb541458b026ced74a8d0352406086cd9ee29825d58bec53913006c1581eaeaaf886f91c17967c7f254c4eeb1e31388a96d4d866cb39f4795bf4cfb3b38a2488d682cc52682950f2654ad3f381ba6d6ec2bf1f9a772564e314c2ab899e89294bb74f953383cb2e2095b08f935897c1e5bb463afba0a6f07e692eca705896743347672038be4e785abc02efe39e1c6b9806b9f33627f9fde6dfde72b9e0cd8460002357d251f818ed23b9f82bfd951d97993d5ee1e62760f20136d00664456a2f8059667b16c7040500506454f9ba856ed90859fd8b3a593f6b28b19e777c124c5ae988b907a452315c9ced6719d5cbabc16421fd876b86d07875f1c5c423c6fb59531ddbea055397be5373b2f89f05eb7f6aab08a4fff1a1989312cf3ca447e3f887acdf9ad9fd331a85741f942eb24fee38a0b93571ba18c91ee4c8c495a1ff94ef1c63ba8e8ea58f54636457e818a12a0997f6ad39d56fbd7d7367ced82b79fd5b8950c7e22a5a9bb8a8f58f094153e9d8af0e4ffe36d274ee5c2a63f08480ade34113e3837ccd2242158c1cef752118c2b20db94bb9d62538259fae00c3707514f9cdfca1dbe5ee99012a6a79b593c0c6b981ad00422553eeb65ac6ecf97c43bd2eb2","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"2f38a9abe27e93441125d58bd936f5de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
